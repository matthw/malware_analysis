#Decrypt Oski stealer strings
#@author Matthieu Walter
#@category matth.malware.oski
#@keybinding 
#@menupath 
#@toolbar 


# put your cursor on the call like:
#
#      004230cd 68 34 a1 42 00           PUSH                 s_D6AGohOHQTY=_0042a134                 = "D6AGohOHQTY="
#      004230d2 e8 99 fe ff ff           CALL                 FUN_00422f70                       <----/// cursor here
#
#  or
#
#   DAT_00432694 = FUN_00422f70("D6AGohOHQTY=");                <----/// cursor here
#
# and run the script


from ghidra.program.model.symbol.RefType import UNCONDITIONAL_CALL
from ghidra.program.util import DefinedDataIterator
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util import DataConverter
from ghidra.program.model.data import PointerDataType

from base64 import b64decode
from string import printable
import re

BLOCK_ADDR = 0xbeef0000
BLOCK_SIZE = 0x6000
#KEY = "056139954853430408"
#KEY = askString("Enter RC4 key", "RC4 key").encode('ascii')


converter = DataConverter.getInstance(currentProgram.getLanguage().isBigEndian())

# https://github.com/HackOvert/GhidraSnippets
# https://gist.github.com/FrankSpierings/3b5e7a1f6c6d791b263765af1fd1d0fe

def rc4crypt(data, key):
    # stolen from OAlabs // no rc4 module in ghidra and no py2.7 install here
    #If the input is a string convert to byte arrays
    if type(data) == str:
        data = [ord(_) for _ in data]
    if type(key) == str:
        key = [ord(_) for _ in key]
    x = 0
    box = list(range(256))
    for i in range(256):
        x = (x + box[i] + key[i % len(key)]) % 256
        box[i], box[x] = box[x], box[i]
    x = 0
    y = 0
    #out = []
    out = ""
    for c in data:
        x = (x + 1) % 256
        y = (y + box[x]) % 256
        box[x], box[y] = box[y], box[x]
        out += chr(c ^ box[(box[x] + box[y]) % 256])
    return out


def find_string_at_address(addr):
    ''' return the string at address
    there must be a better way to do that...
    '''
    for s in DefinedDataIterator.definedStrings(currentProgram):
        if s.address == addr:
            return s

    # didnt find a string
    # create one (like a pig)
    createAsciiString(addr)
    return find_string_at_address(addr)


def decrypt_string(string, key):
    # base64 / rc4
    s = string.getValue()   # unicode
    s = b64decode(s)
    s = rc4crypt(s, key)
    return s



def find_param(insn):
    ''' go up the instruction list to find a PUSH

    look for:
        PUSH addr
    '''
    for x in range(5):
        insn = getInstructionBefore(insn)
        if insn.mnemonicString == u'PUSH':
            str_addr = insn.getOperandReferences(0)[0].getToAddress()
            string = find_string_at_address(str_addr)
            print(string)
            dec = decrypt_string(string, KEY)
            #print(dec)
            return dec
    # failed
    return None


def find_pointer(insn):
    ''' go down the instr list to find where the return value is stored
    
    look for:
        MOV [addr], EAX
    '''
    for x in range(5):
        insn = getInstructionAfter(insn)
        if insn.mnemonicString == u'MOV':
            reg = insn.getRegister(1)
            if reg is None:
                continue

            if reg.name != 'EAX':
                continue
            
            address = insn.getOperandReferences(0)[0].getToAddress()
            return address

    return None



def create_string(string):
    """ we want to store decrypted strings in a new block

    returns a pointer to the new string
    """
    base_addr = toAddr(BLOCK_ADDR)
    block = getMemoryBlock(base_addr)
   
    # block does not exist, create it
    # initialize first DWORD with the offset of next free byte
    if block is None:
        memory = currentProgram.getMemory()
        block = memory.createInitializedBlock("decrypted_strings", toAddr(BLOCK_ADDR), BLOCK_SIZE, 0x0, ConsoleTaskMonitor(), False)
        createDWord(base_addr)
        setPreComment(base_addr, "next free offset for string storage")
        setInt(base_addr, 4)

    # get next free addr
    str_addr = base_addr.add(getInt(base_addr))
    # write string
    setBytes(str_addr, string + '\x00')
    createAsciiString(str_addr, len(string)+1)
    # increment counter
    setInt(base_addr, getInt(base_addr) + len(string) + 1)

    return str_addr


def update_pointer(addr, dest):
    block = getMemoryBlock(addr)
    # initialize memory if not done
    if not block.isInitialized():
        currentProgram.getMemory().convertToInitialized(block, 0)

    removeDataAt(addr)
    # write bytes
    setBytes(addr, converter.getBytes(dest.getOffset()))

    # create pointer
    createData(addr, PointerDataType.dataType)


def process_xref(addr):
    # skip when ref is not call
    if addr.referenceType != UNCONDITIONAL_CALL:
        return

    from_addr = addr.getFromAddress()
    insn = getInstructionAt(from_addr)
    print(insn)

    # find param
    string = find_param(insn)
    if string is None:
        print("error getting param for call @ 0x%x"%from_addr.getOffset())
        return

    print("call @ 0x%x  -> %s"%(from_addr.getOffset(), string))

    # find where it's stored
    pointer = find_pointer(insn)
    if pointer is None:
        print("error getting store value for call @ 0x%x"%from_addr.getOffset())
        return

    print("  * pointer @ 0x%x"%from_addr.getOffset())

    # create string
    address = create_string(string)

    # update pointer
    update_pointer(pointer, address)




def guess_key():
    """ lame key guess
    """
    def is_printable(s):
        for c in s:
            # some strings have NULL byte inside...
            if c not in printable+'\x00':
                return False
        return True


    # pick some (10) base64 looking strings
    test_strings = []
    for s in DefinedDataIterator.definedStrings(currentProgram):
        if re.match("^[A-Za-z0-9/+]+={1,2}$", s.getValue()):
            test_strings.append(s)
        if len(test_strings) >= 10:
            break

    # try all strings as key on the previously selected strings
    for k in DefinedDataIterator.definedStrings(currentProgram):
        
        k = str(k.getValue())
        is_good = True

        for s in test_strings:
            # output must be printable
            if not is_printable(decrypt_string(s, k)):
                is_good = False
                break

        # all 10 strings decoded to something printable
        if is_good:
            return k

    return None







# get instruction at cursor // check it's a CALL
insn = getInstructionAt(currentAddress)
if insn.mnemonicString != u'CALL':
    raise Exception



# guess key or not
if askYesNo("Guess the key", "Do you want to try to guess the key ?"):
    KEY = guess_key()
    if KEY is None:
        KEY = askString("Enter RC4 key", "Couldn't find key, enter it:").encode('ascii')
    print("Using key: %s"%KEY)
else:
    KEY = askString("Enter RC4 key", "RC4 key").encode('ascii') 

# get call destination // that is our our string decryption routing
target_function = insn.getOperandReferences(0)[0].getToAddress()

xrefs = getReferencesTo(target_function)

for xref in xrefs:
    print("#################")
    process_xref(xref)
    #break

