#!/usr/bin/env python3
# unpack stage1 brc4 and extract config
# 01/2023 Matthieu Walter

import sys
import pefile
import struct
import logging
import re
import base64
import angr
from Crypto.Cipher import ARC4
from unicorn import *
from unicorn.x86_const import *
from capstone import *

logging.getLogger('angr.analyses').setLevel('FATAL')

def u64(b):
    return struct.unpack('<Q', b)[0]

def get_section(pe, name):
    data = None
    for section in pe.sections:
        if section.Name.startswith(bytes(name, 'ascii') + b'\x00'):
            return section
    return None


class UnsupportedArchitecture(Exception):
    pass


class BRC4Stage1:
    def __init__(self, filename):
        self.filename = filename
        self.pe = pefile.PE(filename)
        
        if pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine] != 'IMAGE_FILE_MACHINE_AMD64':
            raise UnsupportedArchitecture(pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine])

        self.entry_raw, self.entry_rva, self.raw_size = self.find_entry_point()


    def find_entry_point(self):
        eop = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint

        eop_section = None
        for section in self.pe.sections:
            if section.contains_rva(eop):
                eop_section = section
                break

        # not found
        if eop_section is None:
            return None

        raw_offset = eop_section.PointerToRawData
        rva = self.pe.OPTIONAL_HEADER.ImageBase + eop

        print("entry_point: 0x%x (raw: 0x%x)"%(rva, raw_offset))
        return (raw_offset, rva, eop_section.SizeOfRawData)


    def dump(self, fname_stage2):
        # get code
        with open(self.filename, "rb") as fp:
            fp.seek(self.entry_raw)
            code = fp.read(self.raw_size)

        print("searching for tail jump...")

        # find tail jump address
        tail = None
        # assume 64 bits
        md = Cs(CS_ARCH_X86, CS_MODE_64)
        for i in md.disasm(code, self.entry_rva):
            if i.mnemonic == "jmp":
                print("tail jump -> 0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))
                tail = i.address
                break

        if tail is None:
            return None

        print("emulating from entry to tail jump...")

        # setup env
        ADDR_TEXT  = self.pe.OPTIONAL_HEADER.ImageBase
        ADDR_STACK = 0x7000000

        mu = Uc(UC_ARCH_X86, UC_MODE_64)

        # text segment and stack
        mu.mem_map(ADDR_TEXT,  0x100000)
        mu.mem_map(ADDR_STACK, 0x100000)

        # write code
        mu.mem_write(self.entry_rva, code)

        # setup stack register, that's all we need
        mu.reg_write(UC_X86_REG_RSP, ADDR_STACK + 0x100000)
        mu.reg_write(UC_X86_REG_RBP, ADDR_STACK + 0x100000)

        # emulate from entry up to tail jump
        mu.emu_start(self.entry_rva, tail)

        # get rbp and rsp values
        rbp = mu.reg_read(UC_X86_REG_RBP)
        rsp = mu.reg_read(UC_X86_REG_RSP)

        # read data between these 2
        dump = mu.mem_read(rsp, rbp-rsp)

        # fixup
        dump = bytearray(dump[8:])
        dump[0] = 0x4d  # M
        dump[1] = 0x5a  # Z

        # dump as new file
        with open(fname_stage2, "wb") as fp:
            fp.write(dump)
        print("dumped stage 2 to %s"%fname_stage2)
        return fname_stage2



class BRC4Stage2:
    def __init__(self, filename):
        self.pe = pefile.PE(filename)
        self.filename = filename
        
        if pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine] != 'IMAGE_FILE_MACHINE_AMD64':
            raise UnsupportedArchitecture(pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine])

    def get_config(self):
        overlay = self.get_overlay()
        # overlay format is: size + data + 0
        size = u64(overlay[:8])
        config = overlay[8:8+size]

        # prob unencrypted
        if config.count(b'|') > 6:
            return self.parse_config(config)
        # encrypted config -> base64 then rc4
        else:
            config = self.decrypt_config(base64.b64decode(config))
            return self.parse_config(config)

        return config


    def parse_config(self, config):
        if config is None:
            return None
        else:
            return config.split(b'|')


    def get_overlay(self):
        offset = self.pe.get_overlay_data_start_offset()

        with open(self.filename, 'rb') as fp:
            fp.seek(offset)
            data = fp.read()

        return data


    #
    #  below is to handle config decryption
    #
    def decrypt_config(self, config):
        print("building cfg...")
        self.prj = angr.Project(self.filename, load_options={'auto_load_libs': False})
        self.cfg = self.prj.analyses.CFGFast()

        keys = self.find_keys()
        for k in keys:
            print("trying key %r"%k)
            c = ARC4.new(k)
            dat = c.decrypt(config)
            if dat.count(b'|') > 6:
                return dat

        return None


    def parse_insn(self, insn):
        """ not even ashamed...
        """
        # only works for 64bits, but never seen a 32 bits sample yet
        m = re.findall("rcx, \[rip \+ 0x([a-f0-9]+)\]", insn)
        if len(m):
            return int(m[0], 16) 
        return None


    def get_param_addr(self, block):
        """ ugly but yolo...
        """
        for i in self.prj.factory.block(block.addr).capstone.insns:
            #print("0x%x (%d):\t%s\t%s" %(i.address, i.size, i.mnemonic, i.op_str))
            if i.mnemonic == "lea":
                rel = self.parse_insn(i.op_str)
                if rel is None:
                    continue

                return i.address + i.size + rel 
        return 0


    def find_func_addr(self, addr):
        ''' given any instruction address
        returns the start address of the function it lives in
        '''
        function_addr = None

        # find function
        for node in self.cfg.graph.nodes():
            if addr in node.instruction_addrs:
                function_addr = node.function_address
                break

        # get function entry node
        # cfg.kb.functions.get_by_addr(addr)
        if function_addr is not None:
            for node in self.cfg.graph.nodes():
                if node.addr == function_addr:
                    return node

        return None


    def find_keys(self):
        ''' find potential instructions setting the key
        '''
        # find .text
        print("finding rc4...")
        section = get_section(self.pe, '.text')
        data = section.get_data()

        # 61f8751f 48 ff c0                 INC                  key_len
        # 61f87522 48 3d 00 01 00 00        CMP                  key_len,0x100
        # 61f87528 75 f2                    JNZ                  LAB_61f8751c

        offsets = []
        off = 0
        while True:
            off = data.find(bytes.fromhex("48 ff c0 48 3d 00 01 00 00 75"), off)
            if off == -1:
                break

            offsets.append(self.pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress + off)
            off += 1

        if not len(offsets):
            raise PackerError("no match")

        string_addresses = []

        # find callers
        for offset in offsets:
            func = self.find_func_addr(offset)
            if func is None:
                print("skip 0x%x: not part of a func..."%offset)
                continue

            if not len(func.predecessors):
                print("skip 0x%x: no predecessor..."%offset)
                continue

            # rc4 func is called a lot, skip low counts
            if len(func.predecessors) < 10:
                print("skip 0x%s: too few predecessors (%d) / unlikely to be rc4"%(
                    func.addr, len(func.predecessors)))
                continue

            print("found potential rc4 code: 0x%x"%func.addr)

            for pred in func.predecessors:
                #print(" * found caller (0x%x)"%(pred.addr))
                addr = self.get_param_addr(pred)
                if addr:
                    #print("  + found potential string addr: 0x%x"%addr)
                    string_addresses.append(addr)

        string_addresses = set(string_addresses)
        #print("potential string addr: %r"%string_addresses)

        potential_keys = []
        for addr in string_addresses:
            potential_keys.append(
                    self.pe.get_string_at_rva(addr - self.pe.OPTIONAL_HEADER.ImageBase, 60)
                )

        return set(potential_keys)



if __name__ == "__main__":
    # stage1
    bomb1 = BRC4Stage1(sys.argv[1])
    
    fname_stage2 = sys.argv[1] + ".stage2"
    bomb1.dump(fname_stage2)

    # stage2
    bomb2 = BRC4Stage2(fname_stage2)
    

    cfg = bomb2.get_config()
    if cfg is None:
        print("cannot get config...")
    else:
        print("config:")
        for c in cfg:
            print(" - '%s'"%c.decode())

