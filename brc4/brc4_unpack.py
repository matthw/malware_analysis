#!/usr/bin/env python3
# unpack stage1 brc4 and extract config
# 01/2023 Matthieu Walter

import sys
import pefile
from unicorn import *
from unicorn.x86_const import *
from capstone import *


class UnsupportedArchitecture(Exception):
    pass


class BRC4:
    def __init__(self, filename):
        self.filename = filename
        self.pe = pefile.PE(filename)
        
        match pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine]:
            case 'IMAGE_FILE_MACHINE_AMD64':
                self.arch = CS_MODE_64
            case 'IMAGE_FILE_MACHINE_I386':
                self.arch = CS_MODE_32
            case _:
                raise UnsupportedArchitecture(pefile.MACHINE_TYPE[self.pe.FILE_HEADER.Machine])


        self.entry_raw, self.entry_rva, self.raw_size = self.find_entry_point()


    def find_entry_point(self):
        eop = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint

        eop_section = None
        for section in self.pe.sections:
            if section.contains_rva(eop):
                eop_section = section
                break

        # not found
        if eop_section is None:
            return None

        raw_offset = eop_section.PointerToRawData
        rva = self.pe.OPTIONAL_HEADER.ImageBase + eop

        print("entry_point: 0x%x (raw: 0x%x)"%(rva, raw_offset))
        return (raw_offset, rva, eop_section.SizeOfRawData)


    def dump(self, fname_stage2):
        # get code
        with open(self.filename, "rb") as fp:
            fp.seek(self.entry_raw)
            code = fp.read(self.raw_size)

        print("searching for tail jump...")

        # find tail jump address
        tail = None
        # assume 64 bits
        md = Cs(CS_ARCH_X86, self.arch)
        for i in md.disasm(code, self.entry_rva):
            if i.mnemonic == "jmp":
                print("tail jump -> 0x%x:\t%s\t%s" %(i.address, i.mnemonic, i.op_str))
                tail = i.address
                break

        if tail is None:
            return None

        print("emulating from entry to tail jump...")

        # setup env
        ADDR_TEXT  = self.pe.OPTIONAL_HEADER.ImageBase
        ADDR_STACK = 0x7000000

        mu = Uc(UC_ARCH_X86, UC_MODE_64)

        # text segment and stack
        mu.mem_map(ADDR_TEXT,  0x100000)
        mu.mem_map(ADDR_STACK, 0x100000)

        # write code
        mu.mem_write(self.entry_rva, code)

        # setup stack register, that's all we need
        mu.reg_write(UC_X86_REG_RSP, ADDR_STACK + 0x100000)
        mu.reg_write(UC_X86_REG_RBP, ADDR_STACK + 0x100000)

        # emulate from entry up to tail jump
        mu.emu_start(self.entry_rva, tail)

        # get rbp and rsp values
        rbp = mu.reg_read(UC_X86_REG_RBP)
        rsp = mu.reg_read(UC_X86_REG_RSP)

        # read data between these 2
        dump = mu.mem_read(rsp, rbp-rsp)


        # fixup
        dump = bytearray(dump[8:])
        dump[0] = 0x4d  # M
        dump[1] = 0x5a  # Z

        # dump as new file
        with open(fname_stage2, "wb") as fp:
            fp.write(dump)
        print("dumped stage 2 to %s"%fname_stage2)
        return fname_stage2


    def get_config(self, fname):
        pe = pefile.PE(fname)
        offset = pe.get_overlay_data_start_offset()

        with open(fname, 'rb') as fp:
            fp.seek(offset)
            data = fp.read()

        return data



if __name__ == "__main__":
    bomb = BRC4(sys.argv[1])
    
    fname_stage2 = sys.argv[1] + ".stage2"
    bomb.dump(fname_stage2)

    print("config:")
    for cfg in bomb.get_config(fname_stage2).split(b'|'):
        print(" - %r"%cfg)

